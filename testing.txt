        -:    0:Source:testing.c
        -:    0:Graph:testing.gcno
        -:    0:Data:testing.gcda
        -:    0:Runs:1
        -:    1:#include <stddef.h>
        -:    2:#include <stdint.h>
        -:    3:#include <assert.h>
        -:    4:#include <string.h>
        -:    5:#include <stdio.h>
        -:    6:
        -:    7:// #define SIZE_MAX 0xffffffffffffffffui64
        -:    8:#define H2O_STRLIT(s) (s), sizeof(s) - 1
        -:    9:
        -:   10:#include "testing.h"
        -:   11:
        -:   12:
        -:   13:const h2o_url_scheme_t H2O_URL_SCHEME_HTTP = {{H2O_STRLIT("http")}, 80, 0};
        -:   14:const h2o_url_scheme_t H2O_URL_SCHEME_HTTPS = {{H2O_STRLIT("https")}, 443, 1};
        -:   15:const h2o_url_scheme_t H2O_URL_SCHEME_MASQUE = {{H2O_STRLIT("masque")}, 65535, 0 /* ??? masque might or might not be over TLS */};
        -:   16:
    #####:   17:size_t h2o_strtosize(const char *s, size_t len)
        -:   18:{
    #####:   19:    uint64_t v = 0, m = 1;
    #####:   20:    const char *p = s + len;
        -:   21:
    #####:   22:    if (len == 0)
    #####:   23:        goto Error;
        -:   24:
    #####:   25:    while (1) {
    #####:   26:        int ch = *--p;
    #####:   27:        if (!('0' <= ch && ch <= '9'))
    #####:   28:            goto Error;
    #####:   29:        v += (ch - '0') * m;
    #####:   30:        if (p == s)
    #####:   31:            break;
    #####:   32:        m *= 10;
        -:   33:        /* do not even try to overflow */
    #####:   34:        if (m == 10000000000000000000ULL)
    #####:   35:            goto Error;
        -:   36:    }
        -:   37:
    #####:   38:    if (v >= SIZE_MAX)
    #####:   39:        goto Error;
    #####:   40:    return v;
        -:   41:
    #####:   42:Error:
    #####:   43:    return SIZE_MAX;
        -:   44:}
        -:   45:
    #####:   46:static h2o_iovec_t h2o_iovec_init(const void *base, size_t len)
        -:   47:{
        -:   48:    /* intentionally declared to take a "const void*" since it may contain any type of data and since _some_ buffers are constant */
        -:   49:    h2o_iovec_t buf;
    #####:   50:    buf.base = (char *)base;
    #####:   51:    buf.len = len;
    #####:   52:    return buf;
        -:   53:}
        -:   54:
    #####:   55:const char *h2o_url_parse_hostport(const char *s, size_t len, h2o_iovec_t *host, uint16_t *port)
        -:   56:{
    #####:   57:    const char *token_start = s, *token_end, *end = s + len;
        -:   58:
    #####:   59:    *port = 65535;
        -:   60:
    #####:   61:    if (token_start == end)
    #####:   62:        return NULL;
        -:   63:
    #####:   64:    if (*token_start == '[') {
        -:   65:        /* is IPv6 address */
    #####:   66:        ++token_start;
    #####:   67:        if ((token_end = memchr(token_start, ']', end - token_start)) == NULL)
    #####:   68:            return NULL;
    #####:   69:        *host = h2o_iovec_init(token_start, token_end - token_start);
    #####:   70:        token_start = token_end + 1;
        -:   71:    } else {
    #####:   72:        for (token_end = token_start; !(token_end == end || *token_end == '/' || *token_end == ':'); ++token_end)
        -:   73:            ;
    #####:   74:        *host = h2o_iovec_init(token_start, token_end - token_start);
    #####:   75:        token_start = token_end;
        -:   76:    }
        -:   77:
        -:   78:    /* disallow zero-length host */
    #####:   79:    if (host->len == 0)
    #####:   80:        return NULL;
        -:   81:
        -:   82:    /* parse port */
    #####:   83:    if (token_start != end && *token_start == ':') {
        -:   84:        size_t p;
    #####:   85:        ++token_start;
    #####:   86:        if ((token_end = memchr(token_start, '/', end - token_start)) == NULL)
    #####:   87:            token_end = end;
    #####:   88:        if ((p = h2o_strtosize(token_start, token_end - token_start)) >= 65535)
    #####:   89:            return NULL;
    #####:   90:        *port = (uint16_t)p;
    #####:   91:        token_start = token_end;
        -:   92:    }
        -:   93:
    #####:   94:    return token_start;
        -:   95:}
        -:   96:
        -:   97:
    #####:   98:static int parse_authority_and_path(const char *src, const char *url_end, h2o_url_t *parsed)
        -:   99:{
    #####:  100:    const char *p = h2o_url_parse_hostport(src, url_end - src, &parsed->host, &parsed->_port);
    #####:  101:    if (p == NULL)
    #####:  102:        return -1;
    #####:  103:    parsed->authority = h2o_iovec_init(src, p - src);
    #####:  104:    if (p == url_end) {
    #####:  105:        parsed->path = h2o_iovec_init(H2O_STRLIT("/"));
        -:  106:    } else {
    #####:  107:        if (*p != '/')
    #####:  108:            return -1;
    #####:  109:        parsed->path = h2o_iovec_init(p, url_end - p);
        -:  110:    }
    #####:  111:    return 0;
        -:  112:}
        -:  113:
        1:  114:static const char *parse_scheme(const char *s, const char *end, const h2o_url_scheme_t **scheme)
        -:  115:{
        1:  116:    if (end - s >= 5 && memcmp(s, "http:", 5) == 0) {
    #####:  117:        *scheme = &H2O_URL_SCHEME_HTTP;
    #####:  118:        return s + 5;
        1:  119:    } else if (end - s >= 6 && memcmp(s, "https:", 6) == 0) {
    #####:  120:        *scheme = &H2O_URL_SCHEME_HTTPS;
    #####:  121:        return s + 6;
        1:  122:    } else if (end - s >= 7 && memcmp(s, "masque:", 7) == 0) {
    #####:  123:        *scheme = &H2O_URL_SCHEME_MASQUE;
    #####:  124:        return s + 7;
        -:  125:    }
        1:  126:    return NULL;
        -:  127:}
        -:  128:
        -:  129:
    #####:  130:int h2o_url_parse(const char *url, size_t url_len, h2o_url_t *parsed)
        -:  131:{
        -:  132:    const char *url_end, *p;
        -:  133:
    #####:  134:    if (url_len == SIZE_MAX)
    #####:  135:        url_len = strlen(url);
    #####:  136:    url_end = url + url_len;
        -:  137:
        -:  138:    /* check and skip scheme */
    #####:  139:    if ((p = parse_scheme(url, url_end, &parsed->scheme)) == NULL)
    #####:  140:        return -1;
        -:  141:
        -:  142:    /* skip "//" */
    #####:  143:    if (!(url_end - p >= 2 && p[0] == '/' && p[1] == '/'))
    #####:  144:        return -1;
    #####:  145:    p += 2;
        -:  146:
    #####:  147:    return parse_authority_and_path(p, url_end, parsed);
        -:  148:}
        -:  149:
        1:  150:int main(){
        1:  151:    unsigned long long testValue = 0xFFFFFFFFFFFFFFFF;
        1:  152:    uint8_t *Data = &testValue;
        1:  153:    const char *url = (const char *)Data;
        -:  154:    size_t url_len;
        -:  155:    h2o_url_t uri;
        1:  156:    h2o_url_t *parsed = &uri;
        -:  157:    int ret;
        1:  158:    printf("Test\n");
        -:  159:    const char *url_end, *p;
        -:  160:
        1:  161:    if (url_len == SIZE_MAX)
    #####:  162:        url_len = strlen(url);
        1:  163:    url_end = url + url_len;
        -:  164:
        -:  165:    /* check and skip scheme */
        1:  166:    if ((p = parse_scheme(url, url_end, &parsed->scheme)) == NULL)
        1:  167:        ret = -1;
        1:  168:        goto RET;
        -:  169:
        -:  170:    // /* skip "//" */
        -:  171:    if (!(url_end - p >= 2 && p[0] == '/' && p[1] == '/'))
        -:  172:        ret = -1;
        -:  173:        goto RET;
        -:  174:    p += 2;
        -:  175:
        -:  176:    ret = parse_authority_and_path(p, url_end, parsed);
        -:  177:
        1:  178:    RET:
        -:  179:
        -:  180:
        -:  181:    // ret = h2o_url_parse((const char *)Data, Size, &url);
        1:  182:    if (ret != -1) {
    #####:  183:        printf("Not passed here\n");
    #####:  184:        size_t total = 0, i;
    #####:  185:        assert(uri.scheme != NULL);
    #####:  186:        for (i = 0; i < uri.authority.len; i++)
    #####:  187:            if (uri.authority.base[i])
    #####:  188:                total++;
    #####:  189:        for (i = 0; i < uri.host.len; i++)
    #####:  190:            if (uri.host.base[i])
    #####:  191:                total++;
    #####:  192:        for (i = 0; i < uri.path.len; i++)
    #####:  193:            if (uri.path.base[i])
    #####:  194:                total++;
    #####:  195:        assert(total <= url_len * 2);
        -:  196:    }
        1:  197:    return 0;
        -:  198:}
        -:  199:
